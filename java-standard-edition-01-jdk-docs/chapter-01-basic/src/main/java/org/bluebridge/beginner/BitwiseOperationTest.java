package org.bluebridge.beginner;

import lombok.extern.slf4j.Slf4j;
import org.junit.Test;

/**
 * @author lingwh
 * @desc 位运算
 * @date 2025/7/3 16:58
 */

/**
 * 位运算
 * 1.运算规则
 *      --------------------------------------------------
 *      & 	与 	    两个位都为1时，结果才为1
 *      				●  1 & 1 结果为1 
 *						●  1 & 0 结果为0 
 *						●  0 & 1 结果为0 
 *						●  0 & 0 结果为0 
 *      | 	或 	    两个位都为0时，结果才为0
 *                      ●  1 | 1 结果为1 
 *                      ●  1 | 0 结果为1 
 *                      ●  0 | 1 结果为1
 *                      ●  0 & 0 结果为0 
 *      ^ 	异或 	两个位相同为0，相异为1
 *                      ●  1 ^ 1 结果为0 
 *                      ●  1 ^ 0 结果为1 
 *                      ●  0 ^ 1 结果为1 
 *                      ●  0 ^ 0 结果为0       
 *      ~ 	取反 	0变1，1变0
 *                      ●  ~0就是1 
 *		                ●  ~1就是0 
 *      << 	左移 	各二进位全部左移若干位，高位丢弃，低位补0
 *      >> 	右移 	各二进位全部右移若干位，高位补0或符号位补齐
 *      -------------------------------------------------
 */
@Slf4j
public class BitwiseOperationTest {

	/**
	 * 测试位运算的左右移位
	 * 	1.整型数据(包括正数和负数)支持左右移位，浮点类型数据不支持左右移位
	 *  2.如果向右移位不能整除，则向下取整，如下面的 j = 17
	 *  3.左移和右移分为有符号和无符号
	 *  	有符号移位：运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）
	 *  	无符号移位：运算规则：往右移动后，左边空出来的位直接补0。（正数、负数都适用）
	 */
	@Test
	public void testBitwiseOperation() {
		int i = 4;
		log.info("i有符号右移一位: {}", (i >> 1));
		log.info("i有符号右移两位: {}", (i >> 2));

		log.info("i有符号左移一位: {}", (i << 1));
		log.info("i有符号左移两位: {}", (i << 2));

		//如果不能整除，向下取整
		int j = 17;
		log.info("j有符号右移一位: {}", (j >> 1));
		log.info("j有符号右移两位: {}", (j >> 2));

		int k = -4;
		log.info("k有符号右移一位: {}", (k >> 1));
		log.info("k有符号右移两位: {}", (k >> 2));

		int l = -4;
		log.info("l无符号右移一位: {}", (l >>> 1));
		log.info("l无符号右移两位: {}", (l >>> 2));

		//判断一个数是奇数还是偶数 奇数计算结果为1，偶数计算结果为0
		/**
		 * 0000 0001
		 * 		   &
		 * 0000 0001
		 * 	       =
		 * 0000 0001
		 */
		log.info("1 & 1 = {}", 1 & 1);
		log.info("2 & 1 = {}", 2 & 1);
		log.info("-1 & 1 = {}", -1 & 1);
		log.info("-2 & 1 = {}", -2 & 1);

		//将byte数组中元素转为int类型数据
		byte[] bytes = new byte[]{10,20,30, (byte) 150};
		log.info("bytes[0] & 0xFF = {}", bytes[0] & 0xFF);
		log.info("bytes[1] & 0xFF = {}", bytes[1] & 0xFF);
		log.info("bytes[2] & 0xFF = {}", bytes[2] & 0xFF);
		log.info("bytes[3] & 0xFF = {}", bytes[3] & 0xFF);
	}

}
