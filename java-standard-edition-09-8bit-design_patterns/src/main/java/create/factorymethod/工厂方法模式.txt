工厂方法模式(Factory Method):
    描述:
        工厂方法的主要功能是让父类在不知道具体实现的情况下,完成自身功能的调用,而具体的实现延迟到子类来实现
        把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须
        实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克
        服了简单工厂模式中缺点
    概括：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
    角色分析:
        抽象产品角色(Product):定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。
        具体产品角色(ConcreteProduct):具体的Product接口的实现对象。
        抽象工厂角色(Creator):创建器，声明工厂方法，工厂方法通常会返回一个Product类型的实例对象，而且多是抽象方法。
                            也可以在Creator里面提供工厂方法的默认实现，让工厂方法返回一个缺省的Product类型的实例对象。
        具体工厂角色(ConcreteCreator):具体的创建器对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例。
    优点:
        -面向接口编程，而不面向实现编程
	缺点:每增加一个类，就要对应的创建一个工厂
	IOC和DI分析:
	    使用了IOC和DI会有如下效果,不关心对象的创建,只使用对象
	IOC和DI示例代码:
	    public abstract class A1 {
            /**
            * 工厂方法，创建C1，类似于从子类注入进来的途径
            * @return C1的对象实例
            */
            protected abstract C1 createC1();

            public void t1(){
                //这里需要使用C1类，可是不知道究竟是用哪一个
                //也就不主动去创建C1了，怎么办？
               //反正会在子类里面实现，这里不用管怎么获取C1，直接使用就好了
               createC1().tc();
            }

        }
	深入分析:
	    1.这里的Product可以指很多，可是是一辆车，或者是一个具有特定类型方法的类，如果导出文件的抽象类
	    2.平行的类层次结构
	        假如有两个类层次结构,其中一个类层次中的每个类在另一个类层次中都有一个对应的类结构，
	        就称为平行的类层次结构,使用工厂方法模式可以连接平行的类层次
	示例/场景:
