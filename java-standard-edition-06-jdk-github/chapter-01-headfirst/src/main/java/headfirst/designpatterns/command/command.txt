命令模式:
    角色分析:
        Command:定义命令接口,声明执行的方法
        ConcreteCommand:
            命令接口实现对象,是"虚"的实现,通常会持有接收者,并调用接收者的功能来完成命令要执行的操作
        Receiver:
            接收者,真正执行命令的对象,任何类都可能成为一个接收者,只要它能够实现命令要求实现的响应功能
        Invoker:
            要求命令对象执行请求,并设置命令对象的接收者。注意这个不是我们常规意义上的客户端,而是在组装命令对象
            和接收者,或者把这个Client成为装配者会更好理解,因为真正使用命令的客户端是从Invoker来触发执行的
    深入分析:
        1.将请求封装成对象,以便使用不同的请求、队列或者日志来参数化其他对象,命令模式也支持可撤销的操作
        2.将请求发出的对象和执行请求的对象解耦,被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者
            和一个或者一组动作,调用者通过调用命令对象的execute()发出请求,这会使得接收者的动作被调用
        3.调用者可以接受命令当做参数，甚至可以在运行时动态的进行
        4.聪明的命令对象和傻瓜命令对象
            一般来说,我们尽量设计"傻瓜"命令对象,它只懂得调用一个接收者的一个行为。
            然后,有许多"聪明"命令对象会实现许多逻辑,直接完成一个请求，可以设计聪明的命令对象,
            只是这样依赖,调用者和接收者时间的解耦程度是比不上"傻瓜"命令对象的,而且,也不同够直接把
            接收者当做参数传给命令
        5.如果要实现多层次的撤销操作,撤销到很早以前的状态,需要记录操作执行过程中的每一个命令，并把这些命
            令压入栈中
        6.命令模式可以用来实现事务、日志系统、队列请求、日志请求
