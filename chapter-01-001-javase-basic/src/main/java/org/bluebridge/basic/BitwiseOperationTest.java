package org.bluebridge.basic;

import org.junit.Test;

/**
 * 位运算
 * 1.运算规则
 *      --------------------------------------------------
 *      & 	与 	    两个位都为1时，结果才为1
 *      				●  1 & 1 结果为1 
 *						●  1 & 0 结果为0 
 *						●  0 & 1 结果为0 
 *						●  0 & 0 结果为0 
 *      | 	或 	    两个位都为0时，结果才为0
 *                      ●  1 | 1 结果为1 
 *                      ●  1 | 0 结果为1 
 *                      ●  0 | 1 结果为1
 *                      ●  0 & 0 结果为0 
 *      ^ 	异或 	两个位相同为0，相异为1
 *                      ●  1 ^ 1 结果为0 
 *                      ●  1 ^ 0 结果为1 
 *                      ●  0 ^ 1 结果为1 
 *                      ●  0 ^ 0 结果为0       
 *      ~ 	取反 	0变1，1变0
 *                      ●  ~0就是1 
 *		                ●  ~1就是0 
 *      << 	左移 	各二进位全部左移若干位，高位丢弃，低位补0
 *      >> 	右移 	各二进位全部右移若干位，高位补0或符号位补齐
 *      -------------------------------------------------
 */
public class BitwiseOperationTest {

	/**
	 * 测试位运算的左右移位
	 * 	1.整型数据(包括正数和负数)支持左右移位，浮点类型数据不支持左右移位
	 *  2.如果向右移位不能整除，则向下取整，如下面的 j = 17
	 *  3.左移和右移分为有符号和无符号
	 *  	有符号移位：运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）
	 *  	无符号移位：运算规则：往右移动后，左边空出来的位直接补0。（正数、负数都适用）
	 */
	@Test
	public void testBitwiseOperation() {
		int i = 4;
		System.out.println("i有符号右移一位:" + (i >> 1));
		System.out.println("i有符号右移两位:" + (i >> 2));
		
		System.out.println("i有符号左移一位:" + (i << 1));
		System.out.println("i有符号左移两位:" + (i << 2));
		
		//如果不能整除，向下取整
		int j = 17;
		System.out.println("j有符号右移一位:" + (j >> 1));
		System.out.println("j有符号右移两位:" + (j >> 2));
		
		int k = -4;
		System.out.println("k有符号右移一位:" + (k >> 1));
		System.out.println("k有符号右移两位:" + (k >> 2));
		
		int l = -4;
		System.out.println("l无符号右移一位:" + (l >>> 1));
		System.out.println("l无符号右移两位:" + (l >>> 2));
		
	}
}
