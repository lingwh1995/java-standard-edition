OO四个基本特征:继承、封装、多态、抽象
OO九个基本原则:
	1.找出应用中可能需要变化之处,把他们独立出来，不要和那些不需要变化的代码耦合耦合在一起
		把代码分成状态稳定和状态不稳定的部分，把状态不稳定的部分独立出来并对其进行封装
	2.针对抽象编程，而不针对实现编程
	3.多用组合，少用继承
	    使用组合构建的系统有很大的弹性
	4.为了交互对象之间的松耦合设计而努力
	    如观察者模式中，改变主题或者观察者其中一方，并不会影响到另一方
	5.类应该对扩展开放,对修改关闭
	6.依赖倒置原则(Denpendency Inversion Principle)
	    要依赖抽象,不要依赖具体类,不能让高层组件依赖底层组件,而且不管高层组件或者底层组件,
	    "两者"都应该依赖于抽象,和面向接口编程的区别,这里更强调抽象
	        高层组件:由其他组件定义其行为的类(PizzaStore)
	        低层组件:定义高层组件行为的类(具体的Pizza类)
	    如何做到遵循此原则:
	        变量不可以持有具体的类的引用:用工厂代替new
	        不要让类派生自具体类:请派生自一个抽象(接口或者抽象类)
	        不要覆盖基类中已经实现的方法:如果覆盖基类中已经实现的方法,那么基类就不是一个真正适合
	            被继承的抽象,基类中已经实现的方法,应该有所有的子类共享
    7.最少知道原则:只和直接朋友进行通信,如何实现:尽量避免创建中间对象,如下:
        违反最少知道原则:
           public String test(){
               B b = new A().getB();
               return b.getMessage();
           }
        遵循最少知道原则:
            public String test(){
                 return new A().getMessage();
            }
        如何实现:
            在A类中新增加一个getMessage()方法，使用的时候直接用，不用再先获取B对象了
    8.好莱坞原则
        别调用我们,我们会调用你。 高层组件对代底层组件的方式是:别调用我们，我们会调用你
    9.一个类只有一个引起变化的原则
设计模式和OO的关系:
	OO原则是我们的目标，而设计模式是我们的做法
一些概念的深入理解:
    OO设计的目的:
        可复用、可扩展、可维护
    针对接口编程:
    	1.即针对超类编程,超类指抽象类或者接口
    	2.可以将一个超类聚合到一个类中，作为成员变量
    耦合:
        两个对象之间发生了直接交互,就耦合了
    解耦合:
        两个对象之间发了交互,但是不是直接交互，是通过一个第三方对象做中介进行交互,就解耦合了
    松耦合:
        两个对象之间可以交互,但他们不清楚彼此的细节,通过接口或者抽象类交互，而不是通过实现交互
    关于如何遵守设计原则:
        尽量去遵守,但不一定要遵守,尤其是完全遵守。
    三种创建对象和销毁对象的方案:
        1.一个是当需要使用状态对象的时候创建，使用完后就销毁它们
        2.另一个是提前创建它们并且始终不销毁
        3.采用延迟加载和缓存合用的方式，就是当第一次需要使用状态对象的时候创建，使用完后并不销毁对象，而是把这
          个对象缓存起来，等待下一次使用，而且在合适的时候，会由缓存框架销毁状态对象
    如何选择:
        如果要进入的状态在运行时是不可知的，而且上下文是比较稳定的，不会经常改变状态，而且使用也不频繁，这个时候建议选第一种方案。
        如果状态改变很频繁，也就是需要频繁的创建状态对象，而且状态对象还存储着大量的信息数据，这种情况建议选第二种方案。
        如果无法确定状态改变是否频繁，而且有些状态对象的状态数据量大，有些比较小，一切都是未知的，建议选第三种方案。

    关于继承和组合:
        继承会影响系统弹性,组合影响小一些
        通过继承而获取到的行为,是在编译时静态就决定好的,
        通过组合获取到的行为,是在运行时动态扩展进来的
    高层组件、低层组件和依赖倒转的关系:
        ExportFileApi接口中定义的功能，都是由高层组件ExportOperate来提出的要求，也就是说接口中的功能，是高层组件
        需要的功能。但是高层组件只是提出要求，并不关心如何实现，而低层组件，就是来真正实现高层组件所要求的接口功能的。
        因此看起来，低层实现的接口的所有权并不在底层组件手中，而是倒置到高层组件去了。(简单的理解，高层组件类似于接口,
        底层组件类似实现类)
    什么是接口:
        接口用来定义实现类的外观，也就是实现类的行为定义，用来约束实现类的行为。接口相当用于一份契约,根据外部应用需要的功能,
        约定了实现类应该实现的功能,但是具体的实现类除了实现接口约定的功能外,还可以根据需要实现一些其他的功能,这是允许的，也
        就是说实现类的功能包含但是不仅限于接口约束的功能
    接口详细解读:
        核心思想:
            封装隔离,封装:指的是对被隔离体的行为的封装,而隔离指的是外部调用和内部实现,外部调用只能通过接口进行调用,外部调用是不知道内部具
            体实现的，也就是说外部调用和内部实现是被接口隔离开的
        使用接口的好处:
            由于外部调用和内部实现被接口隔离开了,那么只要接口不变,内部实现的变化就不会影响到外的应用,从而使系统更加灵活,具有更好的扩展性和
            可维护性,这就是所谓的 接口是系统可插拔性的保证
    面向接口编程:
        interface Father{}
        class Son implements Father{}
        /**
         * 下面的写法是多态,不是面向接口编程
         * 面向接口编程要求客户端在使用接口的时候,并不知道该接口的实现类是哪个
         */
        class Client{
            Father son = new Son();
        }

        /**
         * 工厂类
         */
         class Factory{
            public static createFather(){
                return new Son();
            }
         }
         /**
          * 面向接口编程
          */
          class Client {
            //此时客户端只管使用该接口,并不用去关心该接口具体的实现是哪个类
            Father son = Father.crateFather();
          }

