外观模式:
    提供了一个统一的接口,用来访问子系统中的一群接口。外观定义了一个高层接口,让子系统更容易使用
    外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护
    本质是:封装交互,简化调用，很好的体现了最少知道原则
注意事项:
    Facade可以实现为一个类,也可以实现为一个接口
一句话总结:
    让接口的调用更加简单
深入分析:
    1.外观模式只是提供更直接的操作,并没有将原来的子系统阻隔起来。这意味着,如果你的子系统
      需要更高层次的功能,还是可以使用原来的子系统,官方一点的描述:提供简化的接口的同时，依
      然将系统的功能完整的暴露出来,以供需要的人使用
    2.外观模式并不会封装子系统的类,只是提供的简化了对外访问的接口,封装在对外暴露接口的同
      时意味着隐藏内部实现
    3.客户不会和子系统直接交互，而是和外观进行直接交互，这样客户和子系统就解除了耦合
    4.可以为一个系统创建许多个外观
    5.适配器模式的意图是:改变,让接口符合客户的预期
      外观模式:提供子系统的一个简化接口
    6.外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦
      合，从而让外部能够更简单的使用子系统。这点要特别注意，因为外观是当作子系统对外的接口出现的，虽
      然也可以在这里定义一些子系统没有的功能，但不建议这么做。外观应该是包装已有的功能，它主要负责组
      合已有功能来实现客户需要，而不是添加新的实现。

wz.wzbt
wz.createApply
wz.isqy
wz.lmid
wz.startTime
wz.tzjb
wz.id
wz.fjsl
wz.wznr
wz.name
wz.wzbt
wz.createDept
wz.createUserName
wz.lls
wz.createTime