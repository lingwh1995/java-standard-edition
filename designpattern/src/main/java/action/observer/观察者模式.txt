观察者模式:(Observer)
    描述:
        定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己,其本质是
        触发联动
    好处:
        1.观察者模式实现了观察者和目标对象之间的抽象耦合,原本目标对象在状态发生改变的时候,需要调用所有的观察者对象,但是抽象出观察者接口后,目标对象和观察者
          就只是在抽象层面上耦合了,也就是说目标只知道观察者接口,并不知道具体的观察者类,也可以说该模式实现了目标和观察者之间的抽象耦合,从而实现目标和具体的
          观察者之间的解耦
        2.观察者模式实现了动态联动
          联动:做一个操作会引起其相关的操作,由于观察者模式对观察者注册实行管理,MAME就可以在运行期间,通过动态的控制注册的观察者,来控制某个动作的联动范围,
          从而实现动态联动
        3.观察者模式支持广播通信
          由于目标发送通知给观察者是面向所有注册的观察者,所以每次目标的通知信息就要对所有注册的观察者进行广播，所以可以在目标对象升上添加行的功能来控制广播范围
    示例:

    角色分析:
        Subject(目标对象接口):
            一个目标可以被多个观察者观察
            目标提供注册观察者和移除观察者的方法
            当目标状态发生变化时,目标负责通知所有注册的、有效的观察者
        Observer(观察者的接口):
            定义观察者的接口,提供目标通知时对应的更新方法,这个更新方法进行相应
            的业务处理,可以在这个方法里面回调目标对象,以获取目标对象的数据
        ConcreteSubject(目标对象的实现对象):
            用来维护目标状态,当目标对象的状态发生改变时,通知所有注册有效的观察者,让观察者
            执行相应的处理
        ConcreteObserver(具体的观察者):
            观察者的具体实现对象,用来接收目标的通知,并进行相应的后续处理,比如更新自身的状态
            以保持和目标的相应状态一致
    深入分析:
        1.观察者模式分为推拉模型
         推模型:目标对象广播通信,观察者中update方法的参数只是要广播的消息内容
             1.目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当
              于是在广播通信
             2.推模型是假定目标对象知道观察者需要的数据
         拉模型:观察者从目标对象中拉取数据，观察者中update方法的参数的目标对象本身
             1.目标对象在通知观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当
              于是观察者从目标对象中拉数据。
             2.拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。
         推拉模型深入分析:
             推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考虑到的使用情况。
             这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。 而拉模型就不会造成这样的
             情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，基本上可以适应各
             种情况的需要。
        2.观察者模式的两阶段:
             第一个阶段是准备阶段,此阶段完成了如下的工作:
                 创建目标对象
                 创建观察者对象
                 向目标对象注册观察者
             第二个阶段是运行阶段,此阶段完成了如下的工作:
                 改变目标对象的状态
                 通知所有注册的观察者进行相应的处理
                 回调目标对象,获取相应的数据
         多个观察者之间是相互平行的关系,相互之间不应该有先后依赖的关系
        3.在目标对象中,不要把被观察者管理和通知和方法和触发通知的方法定义在一个类里面，而是要把管理观察者的方法抽象到接口中,
          在具体的目标对象中实现触发通知的方法,使得目标对象接口专职提供管理观察者的api,具体的目标对象专职完成触发通知操作
        4.目标对象进行状态维护和触发通知机制的先后先后顺序说明:
         先进行状态的维护,然后再去触发通知机制,错误代码示例:
             以下示例先先触发的通知机制,然后才去进行状态的维护,是错误的
             public void setContent(String content) {
             //一激动，目标先发出通知了，然后才修改自己的数据，这会造成问题
                 notifyAllReader();
                 this.content = content;
             }
         5.高级用法
          在程序运行期间,可以通过动态的控制观察者,来变相的实现添加和删除某些功能，这些功能就是观察者在update的时候执行的功能