概述:实现了抽象与行为实现的分离
    基于类的最小设计原则，同时使用封装、聚合以及继承等行为让不同的类承担不同的职责，
    他的主要特点是把抽象(Abstraction)和行为实现(Implementation)分离开来，从而
    保证各部分的独立性以及对他们功能的扩展
    桥接模式实际上是对面向抽象编程的扩展
角色和职责:
    1.Client:调用端
    2.Abstraction:抽象类，充当桥接类的角色
          抽象类接口，维护行为实现(Implementation)的引用
    3.Refined Abstraction:抽象类子类
    4.Implementor:
          行为实现类接口（Abstraction接口定义了基于Implementor接口更高级层次的操作）
    5.Implementor的子类

优缺点:
优点:
    1.实现了抽象和实现部分的分离
        桥接模式分离了实现部分和抽象部分,从而提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于
        系统的设计，从而产生更好的结构化系统，对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了
    2.抽象部分和实现部分分别独立，又不会相互影响，大大的提升了系统的可扩展性
    3.可动态的切换实现
        由于抽象和实现分离，在选择实现的时候可以动态的切换实现
    4.实现细节对客户端透明，可以对用户隐藏实现的细节
缺点:
    1.桥接模式的引入增加了系统的设计和理解的难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
    2.桥接模式要求正确的识别出系统中两个独立变化的维度，因此，其使用的范围有一定的局限性

使用场景:
    1.如果一个系统要在构建抽象化角色和具体角色之间增加更多的灵活性，避免在建立两个层次以上的额静态的继承关系，通过桥接
        可以使他们在抽象层建立一个抽象关联关系
    2.抽象角色和实现化角色可以以继承的方式独立扩展而不相互影响，在程序运行时可以动态的将一个抽象化子类和一个实现化子类
        的对象进行相互组合，及系统需要对抽象化角色和实际化角色进行动态耦合
    3.一个类存在两个独立变化的维度，而且这两个维度都需要维护
    4.虽然在系统中使用继承时没有问题的，但是由于抽象化角色和具体化角色都需要独立变化，设计者要求独立管理这两者
    5.对于那些不希望使用继承或者因为多层继承导致系统类爆炸的系统，桥接模式尤为适用
    6.不希望再抽象和实现部分采用固定的绑定关系,可以使用桥接模式,来把抽象和具体实现分开,然后在程序运行期间来动态的设置抽象部分
      需要用到的具体实现,还可以动态的切换具体的实现
    7.桥接模式的主要应用场景:抽象和实现部分都需要扩展,可以采用桥接模式,让抽象部分和实现部分可以独立的变化,从而可以灵活的单独
      扩展,而不是搅在一起,一边会影响另一边
示例:
   手机:
        形态(Phone):翻盖、滑盖、直板机
        行为(Brand):Vivo、小米、华为
   消息组件设计:
        形态:短信类型的消息、邮件类型的消息
        行为:发送短信、发送邮件
   银行存款设计:
        形态:银行卡的类型、借记卡/储蓄卡
        行为:活期存储、死期存储
   注意：Abstract类中是多重继承的第一层，Interface中多层继承的第二层
深入理解:
    -一个事物有多种形态并且可以实现多种行为，事物的形态为一个接口，行为表现为一个接口，那么一般情况下事物形态的一个抽象
     父类,当然实现了事物形态接口就是bridge
    注意事项:
        1.在桥接模式中桥接是单向桥，只能是抽象部分的对象去使用实现部分的对象，而不能反过来
        2.为什么需要桥接?
            为了实现达到让抽象部分和实现部分都可以独立变化的目的(为了实现一个事务从两个维度独立变化的目的),抽象部分和实现
            部分只是结构上分开了,但是在抽象部分实现的时候，实际上是持有一个实现部分的引用，通过这个引用调用实现部分的具体
            功能
        3.如何完成桥接
            让抽象部分的抽象类接口拥有实现部分的接口对象，这就桥接上了，在抽象部分就可以通过调用这个接口中来调用具体实现部分
            的功能，也就是说，桥接在程序上提现就是抽象昂昂部分拥有实现部分街门口对象，维护桥接就是维护这个关系
        3.多维度扩展性+独立变化性
            使得抽象和实现可以独立变化,也可以分别扩充，从一个一个角度上来说，抽象部分和实现部分是一种非常松散的关系，从某个
            角度来讲，抽象部分和实现部分是可以完全分开独立的，抽象部分只不过是一个使用实现部分的对外接口的程序罢了
        4.策略模式和桥接模式的区别
            桥接模式的抽象部分类似于策略模式的上下文，但是桥接模式的抽象部分是可以继续变化的，而策略模式只有上下问题，不存在
            所谓的抽象部分
        5.动态变换功能
            由于桥接模式中的抽象部分和实现部分是完全分离的，因此可以在运行时动态组合具体的真实实现，从而达到动态变化功能的目的
            一个抽象可以有多个不同的实现，一个真实实现可以被多个不同的抽象对象调用，比如：站内短消息的实现功能，可以被普通消息、
            加急消息或是特急消息等不同的消息对象使用；反过来，某个消息具体的发送方式，可以是站内短消息，或者是Email，也可以是
            手机短消息等具体的发送方式。
        6.继承和桥接
            继承适合从一个维度对类进行增强和扩展
            桥接模式适合从两个不同的维度对类进行增强和扩展
        7.具体由谁完成桥接
            1.由客户端负责创建Implementor的对象，并在创建抽象部分的对象的时候，把它设置到抽象部分的对象里面去，前面的示例采用的就是这个方式
            2.可以在抽象部分的对象构建的时候，由抽象部分的对象自己来创建相应的Implementor的对象，当然可以给它传递一些参数，它可以根据参数来
            选择并创建具体的Implementor的对象
            3.可以在Abstraction中选择并创建一个缺省的Implementor的对象，然后子类可以根据需要改变这个实现
            4.可以使用抽象工厂或者简单工厂来选择并创建具体的Implementor的对象，抽象部分的类可以通过调用工厂的方法来获取Implementor的对象
            5.如果使用IoC/DI容器的话，还可以通过IoC/DI容器来创建具体的Implementor的对象，并注入回到Abstraction中
        8.桥接模式就是在被分离了的抽象部分和实现部分之间来搭桥,桥接在程序上就形成了在抽象部分拥有实现部分的接口对象,维护桥接就是维护这个关系
        9.桥接模式可以实现运行时动态组合具体的真实实现,从而达到动态变换功能的目的
        10.桥接模式就是对:面向抽象编程 这个原则的扩展
        11.客户是面向抽象的接口在运行,实现部分的修改,可以独立于抽象部分,所以实现部分的修改不会对客户端口产生影响,也可以说对客户端是透明的