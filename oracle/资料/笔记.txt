Java基础加强
1.多态:父类引用指向子类对象
	方法重写依赖于继承，继承依赖于类的实例，静态方法依赖于类，和实例没有什么关系，static方法不能被重写
	Java的多态体现在运行时，静态方法提现在编译时
	构造方法不能被重写，因为构造方式是隐式的static方法
    类的加载全过程：加载->验证->准备->解析->初始化 在这里加载到解析阶段都是JVM进行主导,而在初始化阶段才
        是真正java执行代码的阶段.static成员在初始化阶段之前会被加载到方法区中, 并且进行初始化赋值等操作,
        并且分配内存, 而非static成员确是在初始化后解析后的初始化阶段才会被"加载"分配内存, 也就是代码中使
        用new进行创建实例的时候, 这样也就验证了 类可以直接调用static成员没有问题,而直接调用非static的成
        员就会出问题, 因为违背了java加载初始化的逻辑.
	注意: 如果static调用非static成员 编译器会出现 No enclosing instance of type * is accessible 异常错误.
2.Java内存泄漏与内存溢出
    内存溢出:Out Of Memory:指的是程序在申请内存时，没有足够的空间供其使用
    内存泄漏:Memory Leak:指的是程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏可以忽略，但是多次内存泄漏堆积后果很严重
            Memory Leak最终会导致Out Of Memory
    内存泄漏分为四种:
        1.常发性内存泄漏:
            内存泄漏的代码会多次被执行到,每次执行的时候都会导致一块儿内存泄漏
        2.偶发性内存泄漏:
            发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
        3.一次性内存泄漏:
            发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
        4.隐式内存泄漏:
            程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
3.@SupperssWarnings(“rawtypes”)注解详解:
    rawtypes:传参时也要传递带泛型的参数
    @SuppressWarnings({“static-access”, “unchecked”}):
    指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告。
    deprecation:使用了不赞成使用的类或方法时的警告
    unchecked:执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。
    fallthrough:Switch 程序块直接通往下一种情况而没有 Break 时的警告。
    path:在类路径、源文件路径等中有不存在的路径时的警告。
    serial:当在可序列化的类上缺少 serialVersionUID 定义时的警告。
    finally:任何 finally 子句不能正常完成时的警告。
    all:关于以上所有情况的警告。
4.final
    被final关键字修饰的变量会被jvm缓存,变量的内存地址不会发生变化,所以写的时候不需要进行同步控制,导致写的效率非常高